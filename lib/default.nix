{ inputs }:
let
  # Layers multiple libraries on top of each other, merging them together into
  # a single large attribute set for convenience.
  extensions = inputs.nixpkgs.lib.composeManyExtensions [
    (_: _: inputs.nixpkgs.lib)
    (_: _: inputs.flake-utils.lib)
    (_: _: { mach-nix = inputs.mach-nix.lib; })
  ];

  # `self` is the result of composing all the previous extensions together
  # (note how we use `prev` here rather than making a recursive attribute set.
  # This is intentional)
  #
  # Note: This setup enforces no collisions with any of the previous library
  # names (they won't be overridden by definitions here).
  ourLib = self: {
    enabledPresets = config: self.allEnabled config.preset;
    allEnabled = config: self.filterAttrs (id: value: value.enable or false) config;
    coalescePresets = config: self.coalesce (self.enabledPresets config);
    coalesceFiltered = config: self.coalesce (self.allEnabled config);
    coalesce = config: attr: builtins.catAttrs attr (builtins.attrValues config);
    merge = builtins.foldl' (a: b: a // b) { };
    attrsFromPkgList = builtins.foldl' (a: c: a // { "${self.getName c}" = c; }) { };

    # I'm getting spurious failures for jdk on aarch64-linux, so it's dropped from here.
    flakeSystems = [ "x86_64-darwin" "aarch64-darwin" "x86_64-linux" ];
    forallSystemsMap = self.eachSystemMap self.flakeSystems;
    forallSystems = self.eachSystem self.flakeSystems;
    mkFlake = config: import ./mkFlake.nix { inherit inputs config; lib = self; };
    test-utils = self.forallSystemsMap (system: self.check-utils { inherit system; });
    mkRawConfig = { config, system }: import ./modules {
      lib = self; inherit inputs system config;
    };

    presetUtils = {
      # These update procedures compare before they write, to avoid
      # filesystem churn. This improves performance with watch tools
      casFile = filename: fileToSwap: ''
        if readlink '${filename}' >/dev/null && [[ $(readlink '${filename}') == ${fileToSwap} ]]; then
          echo 1>&2 "generated '${filename}' up to date"
        else
          echo 1>&2 "updating '${filename}'"
          [ -L '${filename}' ] && unlink '${filename}'
          [ -e '${filename}' ] && rm '${filename}'
          ln -s ${fileToSwap} '${filename}'
        fi
      '';

      # These update procedures are unconditional and write files directly to
      # the disk This is intended for files that _should_ be checked into git
      # but are nevertheless generated by nix.
      # These should not be watched by nix (or ideally other filewatch tools)
      writeFile = filename: fileToWrite: ''
        if ! cmp --silent -- '${filename}' '${fileToWrite}'; then
          cat '${fileToWrite}' > '${filename}'
        fi
      '';
    };
  };

in
(inputs.nixpkgs.lib.makeExtensible ourLib).extend extensions
